lnyer: #codebase  Cutscene Randomizer 里面是通过什么逻辑替换场景过场的原始认为模型的

GitHub Copilot: 从代码中可以看出，CutScene Randomizer 替换过场动画中的模型主要通过以下逻辑:

1. 主要替换逻辑在 `src\misc\cutscenes.cc` 文件中的 `CutSceneRandomizer` 类中实现:

2. 核心替换流程如下:

```C++
// 1. 读取模型列表
- 使用 PropsFileName = "CutsceneModelsProps.txt" 作为数据源
- 通过 DataFileBasedModelRandomizer 来管理可替换的模型列表

// 2. 替换逻辑在 RandomizeCutScene 方法中:
- 遍历过场动画文件(cutfCutsceneFile2)中的所有对象
- 对于类型为 MODEL 的对象:
  - 将原始模型的 StreamingName 替换为随机选择的新模型
```

1. 具体替换步骤:

```C++
// 1. 获取随机模型
static uint32_t GetRandomModel(uint32_t modelHash) {
    sm_Randomizer.RandomizeObject(modelHash);
    return modelHash;
}

// 2. 在过场动画中应用替换
for (objects in file->pCutsceneObjects) {
    if (object->type == MODEL) {
        obj->StreamingName = GetRandomModel(obj->StreamingName);
    }
}
```

1. 触发时机:

* 在游戏加载过场动画时触发
* 通过 Hook "8d ? ? 20 0f ba e8 10 89 44 ? ? e8" 来拦截过场动画加载

所以整个替换流程是:

1. 从 C

lnyer: #codebase 根据这个逻辑，它随机选择的模型来自哪里

GitHub Copilot: 从代码分析可以看出，CutScene Randomizer 的模型来源如下：

1. 模型数据来源:

```C++
// 从数据文件 CutsceneModelsProps.txt 中读取可用的模型列表
inline static char PropsFileName[] = "CutsceneModelsProps.txt";
```

1. 模型随机化器:

```C++
// 使用 DataFileBasedModelRandomizer 类来管理和随机化模型
using PropsRandomizer = DataFileBasedModelRandomizer<PropsFileName, 
                                                    CStreaming::GetModelByHash<>>;
```

1. 随机化过程:

```C++
static void RandomizeCutScene(parInstanceVisitor *visitor, cutfCutsceneFile2 *file) {
    // 遍历场景中的所有对象
    for (int i = 0; i < file->pCutsceneObjects.Size; i++) {
        // 对于MODEL类型的对象
        case eCutfObjectType::MODEL: {
            auto obj = static_cast<cutfModelObject *>(file->pCutsceneObjects.Data[i]);
            
            // 使用 GetRandomModel 获取随机模型替换原始模型
            obj->StreamingName = GetRandomModel(obj->StreamingName);
        }
    }
}
```

1. 具体的随机化逻辑:

```C++
static uint32_t GetRandomModel(uint32_t modelHash) {
    // 使用 PropsRandomizer 从预定义的模型列表中随机选择一个模型
    sm_Randomizer.RandomizeObject(modelHash);
    return modelHash;
}
```

所以简单来说:

1. 模型来自 CutsceneModelsProps.txt 文件
2. 该文件中包含了所有可用于随机化的道具模型
3. 通过 DataFileBasedModelRandomizer 从这些模型中随机选择一个来替换原始过场动画中的模型
4. 替换时保持原始模型的其他属性不变,只修改模型本身

lnyer: 人物模型是从哪里获取随机化的

GitHub Copilot: 从代码库分析，人物模型(Ped)的随机化来源主要通过以下方式:

1. 对于过场动画中的人物模型:

```C++
// 使用 CutsceneModelsPeds.txt 文件作为数据源
static CutsPedsRandomizer sm_Randomizer;

// 在 RandomizeCutscenePeds 中进行随机化
void RandomizeCutscenePeds(class CCutsceneAnimatedActorEntity *entity, uint32_t model, bool p3) {
    uint32_t hash = CStreaming::GetModelHash(model);
    
    // 使用 CutsPedsRandomizer 进行随机化 
    if (sm_Randomizer.RandomizeObject(hash)) {
        uint32_t newModel = CStreaming::GetModelIndex(hash);
        // 加载并替换新模型
        ...
    }
}
```

1. 配置控制:

```C++
struct Config {
    bool RandomizePeds           = true;  // 随机路人
    bool RandomizeCutscenePeds   = true;  // 随机过场动画角色
    bool RandomizePlayer         = true;  // 随机玩家模型
    bool UseCutsceneModelsFile  = true;  // 是否使用过场动画模型文件
}
```

所以总结来说:

1. 过场动画角色模型来自 `CutsceneModelsPeds.txt` 文件中预定义的模型列表
2. 通过 `CutsPedsRandomizer` 类实现从可用模型中随机选择
3. 通过配置项可以控制:
   * 是否随机化路人
   * 是否随机化过场动画角色
   * 是否随机化玩家模型
   * 是否使用过场动画模型文件

这样确保了角色模型的随机化是从预定义的合适模型中进行选择,而不是完全随机。

lnyer: #codebase 随机化用来替换原始过场的人物模型，替换后的模型是从哪里获取的

GitHub Copilot: 从代码分析，过场动画中的人物模型(Peds)替换是通过以下方式获取的：

1. 模型数据源在 `CutsceneModelsPeds.txt` 文件中，比如：

```txt
csb_vagspeak
cs_taocheng2
cs_taostranslator2 
csb_agatha
csb_avery
csb_brucie2
csb_thornton
// ... 其他可用的人物模型
```

1. 使用 PedRandomizer 类的 RandomizeCutscenePeds 方法进行随机化：

```C++
static void RandomizeCutscenePeds(class CCutsceneAnimatedActorEntity *entity, uint32_t model, bool p3) {
    static CutsPedsRandomizer sm_Randomizer;

    // 获取原始模型的哈希值    
    uint32_t hash = CStreaming::GetModelHash(model);
    
    // 使用 CutsPedsRandomizer 从CutsceneModelsPeds.txt中随机选择新的模型来替换
    if (sm_Randomizer.RandomizeObject(hash)) {
        uint32_t newModel = CStreaming::GetModelIndex(hash);
        // 加载并应用新模型
        if (!CStreaming::HasModelLoaded(newModel)) {
            CStreaming::RequestModel(newModel, 0);
            CStreaming::LoadAllObjects(false);
        }
    }
}
```

1. 控制替换的条件:

```C++
// 通过配置控制是否启用过场动画角色替换
bool RandomizeCutscenePeds = true;  
bool UseCutsceneModelsFile = true;  // 是否使用CutsceneModelsPeds.txt文件中的模型
```

所以总结来说:

1. 替换模型来自 `CutsceneModelsPeds.txt` 文件中预定义的人物模型列表
2. 通过 CutsPedsRandomizer 类随机从这个列表中选择模型进行替换
3. 可以通过配置控制是否开启替换以及是否使用预定义模型列表

lnyer: #codebase 它好像不仅仅是从CutsceneModelsPeds.txt里面使用模型来替换过场模型吧，因为我添加了一些模组人物有时候过场也会显示模组人物，你分析下，再详细解释下

GitHub Copilot: 通过分析代码,过场动画中的人物模型(Peds)替换来源有以下几个:

1. CutsceneModelsPeds.txt 文件中定义的模型(当UseCutsceneModelsFile=true时):

```C++
constexpr static const char PedsFileName[] = "CutsceneModelsPeds.txt";
using CutsPedsRandomizer = DataFileBasedModelRandomizer<PedsFileName, IsValidPedModel>;
```

1. 游戏当前已加载的所有有效Ped模型(通过PedRandomizer\_Streaming获取):

```C++
void PopulateLoadedPedsSet(std::set<uint32_t> &peds, bool includeNsfw) {
    // 添加所有已加载的Ped模型
    groups->mAppropriatePedsSet.for_each ([&peds] (int val) { peds.insert (val); });
    groups->mInAppropriatePedsSet.for_each ([&peds] (int val) { peds.insert (val); });
    groups->mCopsSet.for_each ([&peds] (int val) { peds.insert (val); });
    groups->mPedsSet5.for_each ([&peds] (int val) { peds.insert (val); });
}
```

1. 可选的是否包含NSFW模型(通过EnableNSFWModels配置控制):

```C++
struct Config {
    bool EnableNSFWModels = false;  // 是否启用NSFW模型
    bool UseCutsceneModelsFile = true; // 是否仅使用CutsceneModelsPeds.txt中的模型
}
```

所以当安装了模组人物时:

* 如果模组添加的人物模型已被游戏加载
* 并且UseCutsceneModelsFile=false或该模型已添加到CutsceneModelsPeds.txt
* 同时该模型未被标记为NSFW(或EnableNSFWModels=true)

那么这个模组人物模型就会加入到可用于随机替换的模型池中,从而在过场动画中出现。

这就解释了为什么有时候会看到模组人物出现在过场动画中 - 因为随机化不仅限于预定义文件中的模型,还包括游戏当前已加载的所有有效Ped模型。

找到具有 1 个许可证类型的类似代码

lnyer: UseCutsceneModelsFile=false 必须为false才会加载模组人物吗

GitHub Copilot: 不是的,通过代码分析,对于过场动画中的人物模型加载有以下规则:

1. 在代码中的核心逻辑:

```C++
static void RandomizeCutscenePeds(CCutsceneAnimatedActorEntity *entity, uint32_t model, bool p3) {
    static CutsPedsRandomizer sm_Randomizer;

    // 获取模型哈希
    uint32_t hash = CStreaming::GetModelHash(model);
    
    // 即使UseCutsceneModelsFile=true,只要模型有效就可以加载
    if (!PR::Config().RandomizeCutscenePeds 
        || !ShouldRandomizePedModel(model)
        || !sm_Randomizer.RandomizeObject(hash)) {
        return;
    }
    
    // 加载新模型
    uint32_t newModel = CStreaming::GetModelIndex(hash);
    if (!CStreaming::HasModelLoaded(newModel)) {
        CStreaming::RequestModel(newModel, 0);
        CStreaming::LoadAllObjects(false);
    }
}
```

1. UseCutsceneModelsFile 的作用是:

* true: 会优先从 CutsceneModelsPeds.txt 文件中获取模型列表
* false: 只从当前游戏已加载的有效Ped模型中选择

所以总结:

1. 无论 UseCutsceneModelsFile 是 true 还是 false,只要模型已被游戏加载并且有效,就可能在过场动画中出现
2. UseCutsceneModelsFile=true 时会增加预定义文件中的模型到随机池,而不是限制只使用文件中的模型
3. 关键是模型需要:
   * 已被游戏加载
   * 是有效的Ped模型
   * 不违反其他限制(如NSFW等)

这就是为什么即使 UseCutsceneModelsFile=true,模组人物模型也可能出现在过场动画中。

lnyer: EnableNSFWModels = true 的功能是什么

GitHub Copilot: 通过代码分析，EnableNSFWModels 的功能是控制是否允许加载被标记为"NSFW"(Not Safe For Work)的模型。

具体实现在以下几个地方:

1. 配置选项定义:

```C++
struct Config {
    bool EnableNSFWModels = false;  // 默认为false,不启用NSFW模型
}
```

1. 在PedRandomizer\_Streaming中过滤NSFW模型:

```C++
void PopulateLoadedPedsSet(std::set<uint32_t> &peds, bool includeNsfw) {
    // ...其他模型加载代码...

    // 当includeNsfw为false时,移除在NSFW_Models.txt中列出的模型
    if(!includeNsfw) {
        // 从NSFW_Models.txt读取需要过滤的模型列表
        // 从peds集合中移除这些NSFW模型
    }
}
```

1. NSFW模型列表在 `data/NSFW_Models.txt` 文件中定义

所以这个选项的作用是:

1. 当 EnableNSFWModels = false 时（默认):
   * 过滤掉所有在NSFW\_Models.txt中列出的模型
   * 这些模型不会出现在随机化过程中
2. 当 EnableNSFWModels = true 时:
   * 不会过滤NSFW\_Models.txt中的模型
   * 所有有效的Ped模型都可能被用于随机化
   * 包括那些被标记为不适合工作场合的模型

这个选项的目的是让用户可以控制是否允许一些可能不适合所有场合的模型出现在游戏中。

lnyer: #codebase RandomizeCutscenePeds功能细分下，增加一个选项，如果开启则不随机过场人物模型，通过读取一个映射列表：
csb\_abigail=cs\_ashley
cs\_lestercrest=cs\_denise
cs\_patricia=a\_f\_m\_business\_02
来替换过场种出现的模型，如果过场的模型不在这个映射列表里面则保存原始模型

GitHub Copilot: 我来帮你实现这个功能。需要以下步骤:

1. 首先在配置文件中添加新选项
2. 创建一个映射文件存储模型对应关系
3. 修改PedRandomizer代码以支持这个功能

具体修改如下:

### [peds.hh](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.hh)

添加新的配置选项:

```C++
class PedRandomizer_Components
{
    static auto &
    Config ()
    {
        static struct Config
        {
            // ...existing code...
            bool UseCutsceneModelMapping = false;  // 是否使用模型映射替换
            std::string CutsceneModelMappingFile = "CutsceneModelMapping.txt";
            // ...existing code...
        } m_Config;
        return m_Config;
    }
    // ...existing code...
}
```

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

修改RandomizeCutscenePeds函数以支持映射替换:

```C++


已进行更改。

class PedRandomizer 
{
    // 添加映射存储
    inline static std::unordered_map<uint32_t, uint32_t> sm_ModelMappings;
    inline static bool sm_ModelMappingsInitialized = false;

    /*******************************************************/
    static void InitializeModelMappings()
    {
        if (sm_ModelMappingsInitialized)
            return;
            
        sm_ModelMappingsInitialized = true;

        FILE* f = Rainbomizer::Common::GetRainbomizerDataFile(
            PR::Config().CutsceneModelMappingFile);
        if (!f)
            return;

        char line[256];
        while (fgets(line, sizeof(line), f))
        {
            char from[128], to[128];
            if (sscanf(line, "%[^=]=%s", from, to) == 2)
            {
                uint32_t fromHash = rage::atStringHash(from);
                uint32_t toHash = rage::atStringHash(to);
                sm_ModelMappings[fromHash] = toHash;
            }
        }
        fclose(f);
    }

    /*******************************************************/
    static void
    RandomizeCutscenePeds(class CCutsceneAnimatedActorEntity* entity, 
                          uint32_t model, bool p3)
    {
        uint32_t hash = CStreaming::GetModelHash(model);

        // 如果启用映射替换
        if (PR::Config().UseCutsceneModelMapping)
        {
            InitializeModelMappings();
            
            auto it = sm_ModelMappings.find(hash);
            if (it != sm_ModelMappings.end())
            {
                hash = it->second;
                uint32_t newModel = CStreaming::GetModelIndex(hash);
                
                if (!CStreaming::HasModelLoaded(newModel))
                {
                    CStreaming::RequestModel(newModel, 0);
                    CStreaming::LoadAllObjects(false);
                }

                if (CStreaming::HasModelLoaded(newModel))
                    PR::nForcedModelNextRandomization = newModel;
            }

            CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
            return;
        }

        // 原有的随机替换逻辑
        static CutsPedsRandomizer sm_Randomizer;
        // ...existing code...
    }
}
```

### [config.toml](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/config.toml)

添加新的配置选项:

```TOML


已进行更改。

[PedRandomizer]
# ...existing code...

# 过场动画模型映射替换
UseCutsceneModelMapping = false 
CutsceneModelMappingFile = "CutsceneModelMapping.txt"
```

### [CutsceneModelMapping.txt](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/data/CutsceneModelMapping.txt)

创建新文件存储映射关系:

```txt


已进行更改。

csb_abigail=cs_ashley
cs_lestercrest=cs_denise  
cs_patricia=a_f_m_business_02
```

这样实现后:

1. 当 UseCutsceneModelMapping=false 时保持原有随机替换功能
2. 当 UseCutsceneModelMapping=true 时:
   * 会读取 CutsceneModelMapping.txt 中的映射关系
   * 如果过场动画中的模型在映射表中存在,则使用映射的模型替换
   * 如果不在映射表中,则保持原模型不变
3. 映射文件采用简单的 model1=model2 格式,便于编辑和维护

已进行更改。

lnyer: #codebase
Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29
=========================================================

\[1741617943]: HudRandomizer: No
\[1741617943]: LightRandomizer: Yes
\[1741617944]: TimecycleRandomizer: No
\[1741617944]: ModCompatibility: Yes
\[1741617944]: Initialising ScriptHook compatibility hooks
\[1741617945]: Registering ExceptionHandlerMgr
\[1741617945]: RainbomizerCredits: No
\[1741617945]: CutSceneRandomizer: Yes
\[1741617945]: RainbomizerNews: No
\[1741617945]: RampRandomizer: Yes
\[1741617945]: RespawnRandomizer: No
\[1741617945]: ScaleformRandomizer: Yes
\[1741617945]: SwitchSceneRandomizer: No
\[1741617945]: TextCaseRandomizer: Yes
\[1741617945]: MissionRandomizer: No
\[1741617945]: ClothesRandomizer: No
\[1741617945]: PedRandomizer: Yes
\[1741617945]: SfxRandomizer: No
\[1741617945]: VoiceLineRandomizer: No
\[1741617945]: VehicleAppearanceRandomizer: No
\[1741617945]: CarGeneratorRandomizer: No
\[1741617945]: DispatchRandomizer: No
\[1741617945]: HandlingRandomizer: No
\[1741617945]: TrafficRandomizer: No
\[1741617945]: ScriptVehicleRandomizer: No
\[1741617945]: WeaponStatsRandomizer: No
\[1741617945]: WeaponRandomizer: No
\[1741617976]: Set Game Build to 3411
\[1741618001]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741618001]: Crossmap.txt file not found or ScriptHook available
\[1741618025]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741618028]: Initialised model hashes
\[1741618028]: Ped models: 1493, Vehicle models: 882
\[1741618034]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory
这是log文件，下面是CutsceneModelMapping.txt文件：
csb\_abigail=cs\_ashley
cs\_lestercrest=cs\_denise
cs\_lestercrest\_2=csb\_money
cs\_lestercrest\_3=csb\_wendy
cs\_patricia=a\_f\_m\_business\_02
这个选项已经设置为了true，UseCutsceneModelMapping = true，但是过场人物还是保持原始外观不是我设置的新模型，比如csb\_abigail没有显示为cs\_ashley，还是随机的，你看看是什么原因

GitHub Copilot: 通过分析代码和日志,发现以下几个问题:

1. RandomizeCutscenePeds函数中的顺序问题 - 映射替换后没有退出函数,导致继续执行后续的随机化代码。

2. 在PedRandomizer构造函数中UseCutsceneModelMapping没有被读取。

让我们修改以下文件:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

修改RandomizeCutscenePeds函数和构造函数:

```C++
class PedRandomizer
{
    // ...existing code...

    template <auto &CCutsceneAnimatedActorEntity__CreatePed>
    static void
    RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                           uint32_t model, bool p3)
    {
        uint32_t hash = CStreaming::GetModelHash (model);

        // 如果启用映射替换
        if (PR::Config().UseCutsceneModelMapping)
        {
            InitializeModelMappings();
            
            auto it = sm_ModelMappings.find(hash);
            if (it != sm_ModelMappings.end())
            {
                hash = it->second; 
                uint32_t newModel = CStreaming::GetModelIndex(hash);
                
                if (!CStreaming::HasModelLoaded(newModel))
                {
                    CStreaming::RequestModel(newModel, 0);
                    CStreaming::LoadAllObjects(false);
                }

                if (CStreaming::HasModelLoaded(newModel))
                {
                    model = CStreaming::GetModelIndex(hash); // 更新model为新模型的索引
                }
            }
            CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
            return;
        }

        // ...existing code...
    }

public:
    PedRandomizer ()
    {
        std::string ForcedPed;
#define OPTION(option) std::pair (#option, &PR::Config ().option)

        if (!ConfigManager::ReadConfig (
                "PedRandomizer", OPTION (ForcedPed), OPTION (RandomizePlayer),
                OPTION (RandomizeCutscenePeds), OPTION (UseCutsceneModelsFile),
                OPTION (ForcedClipset), OPTION (RandomizeSpecialAbility),
                OPTION (IncludeUnusedAbilities),
                OPTION (EnableAnimalMotionFixes), OPTION (EnableAnimalFixes),
                OPTION (EnablePlayerFixes), OPTION (EnableMainFixes),
                OPTION (EnableNoLowBudget), OPTION (EnableBlipsAlwaysVisible),
                OPTION (OddsOfPlayerModels), OPTION(UseCutsceneModelMapping), // 添加此项
                OPTION(CutsceneModelMappingFile)))
            return;

        // ...existing code...
    }
};
```

主要修改内容:

1. RandomizeCutscenePeds函数中:
   * 将hash转换成model索引并直接使用新model替换原始model
   * 在调用CreatePed后立即返回,避免继续执行随机化

2. PedRandomizer构造函数:
   * 添加UseCutsceneModelMapping和CutsceneModelMappingFile到配置读取

这样当UseCutsceneModelMapping=true时:

* 会正确读取映射配置
* 将固定替换模型而不是随机化
* 使用指定的映射模型替换原始模型,如csb\_abigail会被替换为cs\_ashley

建议重新测试过场动画,现在应该会按照CutsceneModelMapping.txt中的映射规则来替换模型了。

已进行更改。

找到具有 1 个许可证类型的类似代码

lnyer: #codebase 1741618616
Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29
=========================================================

\[1741618616]: HudRandomizer: No
\[1741618616]: LightRandomizer: Yes
\[1741618618]: TimecycleRandomizer: No
\[1741618618]: ModCompatibility: Yes
\[1741618618]: Initialising ScriptHook compatibility hooks
\[1741618618]: Registering ExceptionHandlerMgr
\[1741618619]: RainbomizerCredits: No
\[1741618619]: CutSceneRandomizer: Yes
\[1741618619]: RainbomizerNews: No
\[1741618619]: RampRandomizer: Yes
\[1741618619]: RespawnRandomizer: No
\[1741618619]: ScaleformRandomizer: Yes
\[1741618619]: SwitchSceneRandomizer: No
\[1741618619]: TextCaseRandomizer: Yes
\[1741618619]: MissionRandomizer: No
\[1741618619]: ClothesRandomizer: No
\[1741618619]: PedRandomizer: Yes
\[1741618619]: SfxRandomizer: No
\[1741618619]: VoiceLineRandomizer: No
\[1741618619]: VehicleAppearanceRandomizer: No
\[1741618619]: CarGeneratorRandomizer: No
\[1741618619]: DispatchRandomizer: No
\[1741618619]: HandlingRandomizer: No
\[1741618619]: TrafficRandomizer: No
\[1741618619]: ScriptVehicleRandomizer: No
\[1741618619]: WeaponStatsRandomizer: No
\[1741618619]: WeaponRandomizer: No
\[1741618647]: Set Game Build to 3411
\[1741618672]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741618672]: Crossmap.txt file not found or ScriptHook available
\[1741618696]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741618697]: Initialised model hashes
\[1741618697]: Ped models: 1079, Vehicle models: 882
\[1741618699]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory

还是会随机化模型，而不是使用映射表的模型

GitHub Copilot: 检查代码后发现问题在于:

1. 模型映射替换的逻辑错误 - 映射后的newModel没有正确传递给最终的CreatePed调用
2. UseCutsceneModelsFile选项干扰了我们的映射功能

让我们修改以下文件:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

修改RandomizeCutscenePeds函数:

```C++
template <auto &CCutsceneAnimatedActorEntity__CreatePed>
static void
RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                       uint32_t model, bool p3)
{
    uint32_t hash = CStreaming::GetModelHash (model);

    // 如果启用映射替换
    if (PR::Config().UseCutsceneModelMapping)
    {
        InitializeModelMappings();
        
        auto it = sm_ModelMappings.find(hash);
        if (it != sm_ModelMappings.end())
        {
            uint32_t newModel = CStreaming::GetModelIndex(it->second);
            
            if (!CStreaming::HasModelLoaded(newModel))
            {
                CStreaming::RequestModel(newModel, 0);
                CStreaming::LoadAllObjects(false);
            }

            if (CStreaming::HasModelLoaded(newModel))
            {
                CCutsceneAnimatedActorEntity__CreatePed(entity, newModel, p3);
                return;
            }
        }
    }

    // 原有的随机替换逻辑
    if (!PR::Config ().UseCutsceneModelsFile)
    {
        CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
        return;
    }
    
    static CutsPedsRandomizer sm_Randomizer;

    // 随机化模型
    if (!PR::Config ().RandomizeCutscenePeds
        || !ShouldRandomizePedModel (model)
        || !sm_Randomizer.RandomizeObject (hash))
    {
        CCutsceneAnimatedActorEntity__CreatePed (entity, model, p3);
        return;
    }

    // 加载新模型
    uint32_t newModel = CStreaming::GetModelIndex (hash);
    if (!CStreaming::HasModelLoaded (newModel))
    {
        CStreaming::RequestModel (newModel, 0);
        CStreaming::LoadAllObjects (false);
    }

    if (CStreaming::HasModelLoaded (newModel))
    {
        CCutsceneAnimatedActorEntity__CreatePed(entity, newModel, p3);
        return;
    }

    CCutsceneAnimatedActorEntity__CreatePed (entity, model, p3);
}
```

主要修改:

1. 映射替换部分:
   * 当找到映射模型时,直接用newModel调用CreatePed
   * 加载失败时才继续使用原始模型

2. 随机替换部分:
   * 只在UseCutsceneModelsFile=true 且 未找到映射时才执行
   * 每个分支都直接调用CreatePed并返回,避免混合执行

这样当UseCutsceneModelMapping=true时:

1. 优先使用映射表中指定的模型进行替换
2. 如果找不到映射或加载失败,根据UseCutsceneModelsFile选项决定是否执行随机替换
3. 确保每个分支都使用正确的模型调用CreatePed

建议重新测试,现在应该会严格按照映射表进行模型替换了。

已进行更改。

# lnyer: #codebase Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29

\[1741619093]: HudRandomizer: No
\[1741619093]: LightRandomizer: Yes
\[1741619095]: TimecycleRandomizer: No
\[1741619095]: ModCompatibility: Yes
\[1741619095]: Initialising ScriptHook compatibility hooks
\[1741619095]: Registering ExceptionHandlerMgr
\[1741619095]: RainbomizerCredits: No
\[1741619095]: CutSceneRandomizer: Yes
\[1741619096]: RainbomizerNews: No
\[1741619096]: RampRandomizer: Yes
\[1741619096]: RespawnRandomizer: No
\[1741619096]: ScaleformRandomizer: Yes
\[1741619096]: SwitchSceneRandomizer: No
\[1741619096]: TextCaseRandomizer: Yes
\[1741619096]: MissionRandomizer: No
\[1741619096]: ClothesRandomizer: No
\[1741619096]: PedRandomizer: Yes
\[1741619096]: SfxRandomizer: No
\[1741619096]: VoiceLineRandomizer: No
\[1741619096]: VehicleAppearanceRandomizer: No
\[1741619096]: CarGeneratorRandomizer: No
\[1741619096]: DispatchRandomizer: No
\[1741619096]: HandlingRandomizer: No
\[1741619096]: TrafficRandomizer: No
\[1741619096]: ScriptVehicleRandomizer: No
\[1741619096]: WeaponStatsRandomizer: No
\[1741619096]: WeaponRandomizer: No
\[1741619126]: Set Game Build to 3411
\[1741619152]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741619152]: Crossmap.txt file not found or ScriptHook available
\[1741619176]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741619177]: Initialised model hashes
\[1741619177]: Ped models: 1079, Vehicle models: 882
\[1741619179]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory
还是会随机，你浏览整个代码看看是什么原因，CutsceneModelMapping路径是在rainbomizer\data下面

GitHub Copilot: 我发现了两个问题:

1. CutsceneModelMapping文件路径问题 - 我们需要修改GetRainbomizerDataFile的调用方式
2. PedRandomizer和CutSceneRandomizer同时启用导致模型重复randomize

以下是解决方案:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

修改InitializeModelMappings函数中的文件路径处理:

```C++
static void InitializeModelMappings()
{
    // ...existing code...

    FILE* f = Rainbomizer::Common::GetRainbomizerDataFile(
        PR::Config().CutsceneModelMappingFile, "r", "data/");  // 添加data/路径前缀
    
    if (!f)
    {
        Rainbomizer::Logger::LogMessage("Failed to load cutscene model mapping file");
        return; 
    }

    // ...existing code...
}

// ...existing code...

template <auto &CCutsceneAnimatedActorEntity__CreatePed>
static void
RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                       uint32_t model, bool p3)
{
    // 禁用CutSceneRandomizer的随机化
    if (PR::Config().UseCutsceneModelMapping)
    {
        uint32_t hash = CStreaming::GetModelHash(model);
        InitializeModelMappings();
            
        auto it = sm_ModelMappings.find(hash);
        if (it != sm_ModelMappings.end())
        {
            uint32_t newModel = CStreaming::GetModelIndex(it->second);
                
            if (!CStreaming::HasModelLoaded(newModel))
            {
                CStreaming::RequestModel(newModel, 0);
                CStreaming::LoadAllObjects(false);
            }

            if (CStreaming::HasModelLoaded(newModel))
            {
                CCutsceneAnimatedActorEntity__CreatePed(entity, newModel, p3);
                return;
            }
        }
        // 如果映射失败,使用原始模型
        CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
        return;
    }

    // ...existing code...
}
```

### [cutscenes.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/misc/cutscenes.cc)

修改CutSceneRandomizer类以避免与PedRandomizer冲突:

```C++


已进行更改。

class CutSceneRandomizer
{
    // ...existing code...

    static void
    RandomizeCutScene (parInstanceVisitor *visitor, cutfCutsceneFile2 *file)
    {
        // 检查PedRandomizer是否启用了映射
        if (PedRandomizer_Components::Config().UseCutsceneModelMapping)
        {
            VisitTopLevelStructure_37027e(visitor, file); 
            return;
        }

        // ...existing code...
    }
    
    // ...existing code...
}
```

主要改动:

1. 修正了CutsceneModelMapping.txt文件的加载路径,现在会正确在data/目录下查找
2. 当UseCutsceneModelMapping=true时:
   * PedRandomizer的RandomizeCutscenePeds会使用映射替换模型
   * CutSceneRandomizer的随机化逻辑会被禁用,避免重复randomize
3. 添加了加载失败时的日志输出,便于调试

这样应该可以保证严格按照映射文件进行模型替换,而不会发生随机化。请重新测试看看效果。

已进行更改。

lnyer: #codebase 严重性	代码	说明	项目	文件	行	禁止显示状态	详细信息
错误	C2653	“PedRandomizer\_Components”: 不是类或命名空间名称	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\misc\cutscenes.cc	44
错误	C3861	“Config”: 找不到标识符	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\misc\cutscenes.cc	44
错误	C2660	“Rainbomizer::Common::GetRainbomizerDataFile”: 函数不接受 3 个参数	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\peds\peds.cc	164

GitHub Copilot: 让我帮你解决这些编译错误:

1. `GetRainbomizerDataFile`不接受3个参数的问题:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

```C++
// ...existing code...
    static void InitializeModelMappings()
    {
        if (sm_ModelMappingsInitialized)
            return;
            
        sm_ModelMappingsInitialized = true;
        std::string filepath = "data/" + PR::Config().CutsceneModelMappingFile;
        FILE* f = Rainbomizer::Common::GetRainbomizerDataFile(filepath.c_str());
        if (!f)
        {
            Rainbomizer::Logger::LogMessage("Failed to load cutscene model mapping file");
            return; 
        }
// ...existing code...
```

1. 缺少头文件导致的PedRandomizer\_Components不可见问题:

### [cutscenes.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/misc/cutscenes.cc)

````C++


已进行更改。

```cpp
```cpp
```cpp
#include <array>
#include <cstdint>
#include <cstdio>
#include <Utils.hh>
#include <CutSceneManager.hh>
#include "CModelInfo.hh"
#include "CStreaming.hh"
#include "Patterns/Patterns.hh"
#include "common/logger.hh"
#include "common/common.hh"
#include "common/config.hh"
#include "common/parser.hh"
#include "injector/injector.hpp"
#include "CPed.hh"
#include "peds/peds.hh"  // 添加这个头文件

// ...existing code...

    static void
    RandomizeCutScene (parInstanceVisitor *visitor, cutfCutsceneFile2 *file)
    {
        // 检查PedRandomizer是否启用了映射
        auto& config = PedRandomizer_Components::Config();
        if (config.UseCutsceneModelMapping)
        {
            VisitTopLevelStructure_37027e(visitor, file); 
            return;
        }
// ...existing code...
````

主要修改:

1. 修正GetRainbomizerDataFile的调用方式:
   * 合并路径到完整字符串
   * 只传入filepath一个参数

2. 添加缺失的头文件:
   * 在cutscenes.cc中包含"peds/peds.hh"
   * 使用auto&来获取config引用,避免类型推导问题

这样应该可以解决编译错误。让我知道如果你需要任何其他帮助。

已进行更改。

找到具有 1 个许可证类型的类似代码

# lnyer: #codebase Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29

\[1741619889]: HudRandomizer: No
\[1741619889]: LightRandomizer: Yes
\[1741619891]: TimecycleRandomizer: No
\[1741619891]: ModCompatibility: Yes
\[1741619891]: Initialising ScriptHook compatibility hooks
\[1741619891]: Registering ExceptionHandlerMgr
\[1741619892]: RainbomizerCredits: No
\[1741619892]: CutSceneRandomizer: Yes
\[1741619892]: RainbomizerNews: No
\[1741619892]: RampRandomizer: Yes
\[1741619892]: RespawnRandomizer: No
\[1741619892]: ScaleformRandomizer: Yes
\[1741619892]: SwitchSceneRandomizer: No
\[1741619892]: TextCaseRandomizer: Yes
\[1741619892]: MissionRandomizer: No
\[1741619892]: ClothesRandomizer: No
\[1741619892]: PedRandomizer: Yes
\[1741619892]: SfxRandomizer: No
\[1741619892]: VoiceLineRandomizer: No
\[1741619892]: VehicleAppearanceRandomizer: No
\[1741619892]: CarGeneratorRandomizer: No
\[1741619892]: DispatchRandomizer: No
\[1741619892]: HandlingRandomizer: No
\[1741619892]: TrafficRandomizer: No
\[1741619892]: ScriptVehicleRandomizer: No
\[1741619892]: WeaponStatsRandomizer: No
\[1741619892]: WeaponRandomizer: No
\[1741619920]: Set Game Build to 3411
\[1741619945]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741619945]: Crossmap.txt file not found or ScriptHook available
\[1741619969]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741619970]: Initialised model hashes
\[1741619970]: Ped models: 1079, Vehicle models: 882
\[1741619972]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory
还是会在剧情过场随机化人物，你看看是不是随机化和指定模型还是有哪里衔接不好

GitHub Copilot: 从日志来看，主要问题是过场动画中的人物模型依然在随机化，而不是按照映射文件来替换。让我们修复这些问题:

1. 修复CutSceneRandomizer避免与PedRandomizer冲突
2. 确保映射文件路径正确处理
3. 修复过场动画人物模型的切换逻辑

以下是具体修改方案:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

修改InitializeModelMappings函数,增加日志输出:

```C++
    static void InitializeModelMappings()
    {
        if (sm_ModelMappingsInitialized)
            return;
            
        sm_ModelMappingsInitialized = true;
        
        // 不要拼接data/路径,让GetRainbomizerDataFile自己处理
        FILE* f = Rainbomizer::Common::GetRainbomizerDataFile(
            PR::Config().CutsceneModelMappingFile.c_str());
        
        if (!f)
        {
            Rainbomizer::Logger::LogMessage(
                "Failed to load cutscene model mapping file: %s",
                PR::Config().CutsceneModelMappingFile.c_str());
            return; 
        }

        Rainbomizer::Logger::LogMessage("Loading cutscene model mappings...");
        
        char line[256];
        int count = 0;
        while (fgets(line, sizeof(line), f))
        {
            char from[128], to[128];
            if (sscanf(line, "%[^=]=%s", from, to) == 2)
            {
                uint32_t fromHash = rage::atStringHash(from);
                uint32_t toHash = rage::atStringHash(to);
                sm_ModelMappings[fromHash] = toHash;
                count++;
                
                Rainbomizer::Logger::LogMessage(
                    "Added mapping: %s (%X) -> %s (%X)", 
                    from, fromHash, to, toHash);
            }
        }
        
        Rainbomizer::Logger::LogMessage(
            "Loaded %d cutscene model mappings", count);
        
        fclose(f);
    }

// ...existing code...
```

### [cutscenes.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/misc/cutscenes.cc)

让CutSceneRandomizer完全尊重PedRandomizer的配置:

```C++


已进行更改。

    static void
    RandomizeCutScene (parInstanceVisitor *visitor, cutfCutsceneFile2 *file)
    {
        // 如果启用了PedRandomizer的过场动画模型映射,则跳过随机化
        if (PedRandomizer_Components::Config().UseCutsceneModelsFile || 
            PedRandomizer_Components::Config().UseCutsceneModelMapping)
        {
            VisitTopLevelStructure_37027e(visitor, file);
            return;
        }

        // ...existing code...
    }
```

这样应该可以:

1. 正确加载并检查映射文件
2. 避免CutSceneRandomizer和PedRandomizer之间的冲突
3. 提供更详细的日志方便调试
4. 确保过场动画模型按照映射文件执行替换

需要注意的是:

1. 将CutsceneModelMapping.txt文件放在data目录下
2. 确保文件内容格式正确(from=to格式)
3. 检查日志确认映射是否正确加载

让我知道如果还有任何问题。

已进行更改。

# lnyer: #codebase Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29

\[1741620338]: HudRandomizer: No
\[1741620338]: LightRandomizer: Yes
\[1741620340]: TimecycleRandomizer: No
\[1741620340]: ModCompatibility: Yes
\[1741620340]: Initialising ScriptHook compatibility hooks
\[1741620340]: Registering ExceptionHandlerMgr
\[1741620340]: RainbomizerCredits: No
\[1741620340]: CutSceneRandomizer: Yes
\[1741620340]: RainbomizerNews: No
\[1741620340]: RampRandomizer: Yes
\[1741620340]: RespawnRandomizer: No
\[1741620340]: ScaleformRandomizer: Yes
\[1741620340]: SwitchSceneRandomizer: No
\[1741620340]: TextCaseRandomizer: Yes
\[1741620340]: MissionRandomizer: No
\[1741620340]: ClothesRandomizer: No
\[1741620340]: PedRandomizer: Yes
\[1741620341]: SfxRandomizer: No
\[1741620341]: VoiceLineRandomizer: No
\[1741620341]: VehicleAppearanceRandomizer: No
\[1741620341]: CarGeneratorRandomizer: No
\[1741620341]: DispatchRandomizer: No
\[1741620341]: HandlingRandomizer: No
\[1741620341]: TrafficRandomizer: No
\[1741620341]: ScriptVehicleRandomizer: No
\[1741620341]: WeaponStatsRandomizer: No
\[1741620341]: WeaponRandomizer: No
\[1741620369]: Set Game Build to 3411
\[1741620394]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741620394]: Crossmap.txt file not found or ScriptHook available
\[1741620418]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741620419]: Initialised model hashes
\[1741620419]: Ped models: 1079, Vehicle models: 882
\[1741620420]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory
\[1741620435]: Loading cutscene model mappings...
\[1741620435]: Added mapping: csb\_abigail (89768941) -> cs\_ashley (26C3D079)
\[1741620435]: Added mapping: cs\_lestercrest (B594F5C3) -> cs\_denise (6F802738)
\[1741620435]: Added mapping: cs\_lestercrest\_2 (B63911D) -> csb\_money (989DFD9A)
\[1741620435]: Added mapping: cs\_lestercrest\_3 (1D953580) -> csb\_wendy (55A789AF)
\[1741620435]: Added mapping: cs\_patricia (DF8B1301) -> a\_f\_m\_business\_02 (1FC37DBC)
\[1741620435]: Added mapping: player\_zero (D7114C9) -> csb\_golfer\_a (7E5F1188)
\[1741620435]: Added mapping: player\_one (9B22DBAF) -> csb\_jio (A28B9E2D)
\[1741620435]: Added mapping: player\_two (9B810FA2) -> csb\_juanstrickler (D74B8139)
\[1741620435]: Loaded 8 cutscene model mappings
依然还是随机的，是不是哈希值的格式有问题没有0x，比如csb\_abigail应该是0x89768941，cs\_ashley是0x26C3D079。或者其他问题，你浏览下整个代码

GitHub Copilot: 我来帮你解决这个问题。通过日志可以看到映射文件已经正确加载了，但是模型替换没有生效。让我们检查下代码:

1. 修改 PedRandomizer::RandomizeCutscenePeds 的映射逻辑:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

```C++
// ...existing code...
    template <auto &CCutsceneAnimatedActorEntity__CreatePed>
    static void
    RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                           uint32_t model, bool p3)
    {
        // 检查映射替换
        if (PR::Config().UseCutsceneModelMapping)
        {
            InitializeModelMappings();
            
            // 获取当前模型的哈希值
            uint32_t origHash = CStreaming::GetModelHash(model);
            Rainbomizer::Logger::LogMessage(
                "Looking up mapping for model: %X", origHash);
                
            auto it = sm_ModelMappings.find(origHash);
            if (it != sm_ModelMappings.end())
            {
                uint32_t newHash = it->second;
                uint32_t newModel = CStreaming::GetModelIndex(newHash);
                
                Rainbomizer::Logger::LogMessage(
                    "Found mapping %X -> %X (model id: %d)", 
                    origHash, newHash, newModel);
                    
                if (newModel != -1)
                {
                    if (!CStreaming::HasModelLoaded(newModel))
                    {
                        CStreaming::RequestModel(newModel, 0);
                        CStreaming::LoadAllObjects(false);
                    }

                    if (CStreaming::HasModelLoaded(newModel))
                    {
                        Rainbomizer::Logger::LogMessage(
                            "Applying mapped model %X", newHash);
                        CCutsceneAnimatedActorEntity__CreatePed(entity, newModel, p3);
                        return;
                    }
                }
            }
            
            Rainbomizer::Logger::LogMessage(
                "No mapping found for model %X, using original", origHash);
        }

        // ... existing random replacement logic...
    }
// ...existing code...
```

1. 确保过场动画不会被CutSceneRandomizer再次随机化:

### [cutscenes.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/misc/cutscenes.cc)

```C++


已进行更改。

    static void
    RandomizeCutScene (parInstanceVisitor *visitor, cutfCutsceneFile2 *file)
    {
        // 检查PedRandomizer的映射功能是否启用
        auto& config = PedRandomizer_Components::Config();
        if (config.UseCutsceneModelMapping || config.UseCutsceneModelsFile)
        {
            Rainbomizer::Logger::LogMessage(
                "CutSceneRandomizer: Skipping due to PedRandomizer model mapping");
            VisitTopLevelStructure_37027e(visitor, file);
            return;
        }

        // ...existing code...
    }
```

主要修改:

1. 在RandomizeCutscenePeds中增加了详细的日志以跟踪替换过程
2. 修复了模型ID的获取和验证逻辑
3. 加强了CutSceneRandomizer和PedRandomizer之间的协调
4. 添加了对无效model index的检查

观察日志,我们可以:

1. 确认映射表是否正确加载
2. 查看具体哪个环节出了问题
3. 验证模型哈希值和ID是否正确转换

另外，哈希值的格式问题不影响 - atStringHash函数会自动处理数字格式。关键是要确保:

1. 正确读取原始模型的哈希值
2. 正确查找映射关系
3. 正确转换新模型的哈希值到模型ID

让我知道修改后的结果。

已进行更改。

# lnyer: #codebase Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29

\[1741620996]: HudRandomizer: No
\[1741620996]: LightRandomizer: Yes
\[1741620997]: TimecycleRandomizer: No
\[1741620997]: ModCompatibility: Yes
\[1741620997]: Initialising ScriptHook compatibility hooks
\[1741620998]: Registering ExceptionHandlerMgr
\[1741620998]: RainbomizerCredits: No
\[1741620998]: CutSceneRandomizer: Yes
\[1741620998]: RainbomizerNews: No
\[1741620998]: RampRandomizer: Yes
\[1741620998]: RespawnRandomizer: No
\[1741620998]: ScaleformRandomizer: Yes
\[1741620998]: SwitchSceneRandomizer: No
\[1741620998]: TextCaseRandomizer: Yes
\[1741620998]: MissionRandomizer: No
\[1741620998]: ClothesRandomizer: No
\[1741620998]: PedRandomizer: Yes
\[1741620998]: SfxRandomizer: No
\[1741620998]: VoiceLineRandomizer: No
\[1741620998]: VehicleAppearanceRandomizer: No
\[1741620998]: CarGeneratorRandomizer: No
\[1741620998]: DispatchRandomizer: No
\[1741620998]: HandlingRandomizer: No
\[1741620998]: TrafficRandomizer: No
\[1741620998]: ScriptVehicleRandomizer: No
\[1741620998]: WeaponStatsRandomizer: No
\[1741620998]: WeaponRandomizer: No
\[1741621026]: Set Game Build to 3411
\[1741621051]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD)
\[1741621051]: Crossmap.txt file not found or ScriptHook available
\[1741621075]: rage::gameSkeleton::Init(INIT\_SESSION)
\[1741621076]: Initialised model hashes
\[1741621076]: Ped models: 1079, Vehicle models: 882
\[1741621077]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory555
\[1741621094]: CutSceneRandomizer: Skipping due to PedRandomizer model mapping
\[1741621095]: Loading cutscene model mappings...
\[1741621095]: Added mapping: csb\_abigail (89768941) -> cs\_ashley (26C3D079)
\[1741621095]: Added mapping: cs\_lestercrest (B594F5C3) -> cs\_denise (6F802738)
\[1741621095]: Added mapping: cs\_lestercrest\_2 (B63911D) -> csb\_money (989DFD9A)
\[1741621095]: Added mapping: cs\_lestercrest\_3 (1D953580) -> csb\_wendy (55A789AF)
\[1741621095]: Added mapping: cs\_patricia (DF8B1301) -> a\_f\_m\_business\_02 (1FC37DBC)
\[1741621095]: Added mapping: player\_zero (D7114C9) -> csb\_golfer\_a (7E5F1188)
\[1741621095]: Added mapping: player\_one (9B22DBAF) -> csb\_jio (A28B9E2D)
\[1741621095]: Added mapping: player\_two (9B810FA2) -> csb\_juanstrickler (D74B8139)
\[1741621095]: Loaded 8 cutscene model mappings
\[1741621095]: Looking up mapping for model: D7114C9
\[1741621095]: Found mapping D7114C9 -> 7E5F1188 (model id: 15648)
\[1741621095]: Applying mapped model 7E5F1188
\[1741621095]: Looking up mapping for model: 89768941
\[1741621095]: Found mapping 89768941 -> 26C3D079 (model id: 7308)
\[1741621095]: Applying mapped model 26C3D079
\[1741621205]: CutSceneRandomizer: Skipping due to PedRandomizer model mapping
\[1741621205]: Looking up mapping for model: 89768941
\[1741621205]: Found mapping 89768941 -> 26C3D079 (model id: 7308)
\[1741621205]: Applying mapped model 26C3D079
\[1741621244]: CutSceneRandomizer: Skipping due to PedRandomizer model mapping
\[1741621244]: Looking up mapping for model: B594F5C3
\[1741621244]: Found mapping B594F5C3 -> 6F802738 (model id: 7333)
\[1741621244]: Applying mapped model 6F802738
\[1741621244]: Looking up mapping for model: 9B22DBAF
\[1741621244]: Found mapping 9B22DBAF -> A28B9E2D (model id: 8342)
\[1741621244]: Applying mapped model A28B9E2D
\[1741621315]: CutSceneRandomizer: Skipping due to PedRandomizer model mapping
\[1741621316]: Looking up mapping for model: 89768941
\[1741621316]: Found mapping 89768941 -> 26C3D079 (model id: 7308)
\[1741621316]: Applying mapped model 26C3D079

显示有加载，但是还是会随机，你看看是不是看看随机化的逻辑看看是哪里冲突

GitHub Copilot: 根据日志,我发现了几个问题:

1. 配置已经正确加载,映射文件也成功读取并应用
2. CutSceneRandomizer 已正确跳过随机化
3. PedRandomizer 的映射逻辑似乎仍在与其他随机化逻辑冲突

让我们修改这些文件:

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

关键修改在 RandomizeCutscenePeds 函数中:

```C++
    template <auto &CCutsceneAnimatedActorEntity__CreatePed>
    static void
    RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                           uint32_t model, bool p3)
    {
        // 优先检查映射替换
        if (PR::Config().UseCutsceneModelMapping)
        {
            InitializeModelMappings();
            
            uint32_t origHash = CStreaming::GetModelHash(model);
            Rainbomizer::Logger::LogMessage(
                "Looking up mapping for model: %X", origHash);
                
            auto it = sm_ModelMappings.find(origHash);
            if (it != sm_ModelMappings.end())
            {
                uint32_t newHash = it->second;
                uint32_t newModel = CStreaming::GetModelIndex(newHash);
                
                Rainbomizer::Logger::LogMessage(
                    "Found mapping %X -> %X (model id: %d)", 
                    origHash, newHash, newModel);
                    
                if (newModel != -1)
                {
                    if (!CStreaming::HasModelLoaded(newModel))
                    {
                        CStreaming::RequestModel(newModel, 0);
                        CStreaming::LoadAllObjects(false);
                    }

                    if (CStreaming::HasModelLoaded(newModel))
                    {
                        Rainbomizer::Logger::LogMessage(
                            "Applying mapped model %X", newHash);
                        CCutsceneAnimatedActorEntity__CreatePed(entity, newModel, p3);
                        return;
                    }
                }
            }
            
            // 如果找不到映射或加载失败,使用原始模型
            Rainbomizer::Logger::LogMessage(
                "No mapping/loading failed for model %X, using original", origHash);
            CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
            return;
        }

        // 如果没启用映射替换,才执行以下的随机化逻辑
        if (!PR::Config ().UseCutsceneModelsFile)
        {
            CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
            return;
        }
        
        // ... existing random replacement logic ...
    }
```

### [cutscenes.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/misc/cutscenes.cc)

确保 CutSceneRandomizer 完全禁用:

```C++


已进行更改。

    static void
    RandomizeCutScene (parInstanceVisitor *visitor, cutfCutsceneFile2 *file)
    {
        // 如果 PedRandomizer 启用了映射或模型文件,完全跳过 CutSceneRandomizer
        auto& config = PedRandomizer_Components::Config();
        if (config.UseCutsceneModelMapping || config.UseCutsceneModelsFile)
        {
            Rainbomizer::Logger::LogMessage(
                "CutSceneRandomizer: Skipping due to PedRandomizer features");
            VisitTopLevelStructure_37027e(visitor, file);
            return;
        }

        // ... existing cutscene randomization code ...
    }
```

主要改动:

1. 将映射替换逻辑放在最优先位置检查
2. 如果启用了映射,忽略所有其他随机化逻辑
3. 加强了错误处理和日志记录
4. 确保 CutSceneRandomizer 完全禁用

这样应该可以:

1. 优先使用映射文件替换模型
2. 避免与其他随机化逻辑冲突
3. 提供更详细的错误日志定位问题

让我知道这些修改后的效果。

已进行更改。

lnyer: #codebase 严重性	代码	说明	项目	文件	行	禁止显示状态	详细信息
错误	C2065	“hash”: 未声明的标识符	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\peds\peds.cc	264
错误	C2065	“hash”: 未声明的标识符	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\peds\peds.cc	271

GitHub Copilot: 我发现问题了 - 在 RandomizeCutscenePeds 函数中使用了未声明的变量 `hash`。让我帮你修复这个问题。

### [peds.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.cc)

主要修改位置是在 RandomizeCutscenePeds 函数中添加变量声明:

```C++
/*...existing code...*/
    template <auto &CCutsceneAnimatedActorEntity__CreatePed>
    static void
    RandomizeCutscenePeds (class CCutsceneAnimatedActorEntity *entity,
                           uint32_t model, bool p3)
    {
        // 优先检查映射替换
        if (PR::Config().UseCutsceneModelMapping)
        {
            // ...existing mapping code...
        }

        // 如果没启用映射替换,才执行以下的随机化逻辑
        if (!PR::Config ().UseCutsceneModelsFile)
        {
            CCutsceneAnimatedActorEntity__CreatePed(entity, model, p3);
            return;
        }
        
        static CutsPedsRandomizer sm_Randomizer;

        // 获取模型哈希值
        uint32_t hash = CStreaming::GetModelHash(model);

        // 随机化模型
        if (!PR::Config ().RandomizeCutscenePeds
            || !ShouldRandomizePedModel (model)
            || !sm_Randomizer.RandomizeObject (hash))
        {
            CCutsceneAnimatedActorEntity__CreatePed (entity, model, p3);
            return;
        }

        // ... rest of existing code ...
    }
/*...existing code...*/
```

修改内容:

1. 在使用 `hash` 之前添加了变量声明: `uint32_t hash = CStreaming::GetModelHash(model);`
2. 保持其他代码逻辑不变
3. 确保变量在正确的作用域内被声明和使用

这样应该可以解决编译错误。主要问题是变量使用前未声明,添加声明后就可以正常编译了。

已进行更改。

lnyer: #codebase Rainbomizer V Build: Release v3.3.7: Mar 10 2025 22:30:29
\[1741621802]: HudRandomizer: No \[1741621802]: LightRandomizer: Yes \[1741621804]: TimecycleRandomizer: No \[1741621804]: ModCompatibility: Yes \[1741621804]: Initialising ScriptHook compatibility hooks \[1741621804]: Registering ExceptionHandlerMgr \[1741621804]: RainbomizerCredits: No \[1741621804]: CutSceneRandomizer: Yes \[1741621804]: RainbomizerNews: No \[1741621804]: RampRandomizer: Yes \[1741621804]: RespawnRandomizer: No \[1741621804]: ScaleformRandomizer: Yes \[1741621804]: SwitchSceneRandomizer: No \[1741621804]: TextCaseRandomizer: Yes \[1741621804]: MissionRandomizer: No \[1741621804]: ClothesRandomizer: No \[1741621804]: PedRandomizer: Yes \[1741621805]: SfxRandomizer: No \[1741621805]: VoiceLineRandomizer: No \[1741621805]: VehicleAppearanceRandomizer: No \[1741621805]: CarGeneratorRandomizer: No \[1741621805]: DispatchRandomizer: No \[1741621805]: HandlingRandomizer: No \[1741621805]: TrafficRandomizer: No \[1741621805]: ScriptVehicleRandomizer: No \[1741621805]: WeaponStatsRandomizer: No \[1741621805]: WeaponRandomizer: No \[1741621833]: Set Game Build to 3411 \[1741621858]: rage::gameSkeleton::Init(AFTER\_MAP\_LOAD) \[1741621858]: Crossmap.txt file not found or ScriptHook available \[1741621882]: rage::gameSkeleton::Init(INIT\_SESSION) \[1741621883]: Initialised model hashes \[1741621883]: Ped models: 1079, Vehicle models: 882 \[1741621884]: Failed to read Rainbomizer data file: data/PedsBlacklist.txt: No such file or directory \[1741621903]: CutSceneRandomizer: Skipping due to PedRandomizer features \[1741621903]: Loading cutscene model mappings... \[1741621903]: Added mapping: csb\_abigail (89768941) -> cs\_ashley (26C3D079) \[1741621903]: Added mapping: cs\_lestercrest (B594F5C3) -> cs\_denise (6F802738) \[1741621903]: Added mapping: cs\_lestercrest\_2 (B63911D) -> csb\_money (989DFD9A) \[1741621903]: Added mapping: cs\_lestercrest\_3 (1D953580) -> csb\_wendy (55A789AF) \[1741621903]: Added mapping: cs\_patricia (DF8B1301) -> a\_f\_m\_business\_02 (1FC37DBC) \[1741621903]: Added mapping: player\_zero (D7114C9) -> csb\_golfer\_a (7E5F1188) \[1741621903]: Added mapping: player\_one (9B22DBAF) -> csb\_jio (A28B9E2D) \[1741621903]: Added mapping: player\_two (9B810FA2) -> csb\_juanstrickler (D74B8139) \[1741621903]: Loaded 8 cutscene model mappings \[1741621903]: Looking up mapping for model: D7114C9 \[1741621903]: Found mapping D7114C9 -> 7E5F1188 (model id: 15648) \[1741621903]: Applying mapped model 7E5F1188 \[1741621903]: Looking up mapping for model: 89768941 \[1741621903]: Found mapping 89768941 -> 26C3D079 (model id: 7308) \[1741621903]: Applying mapped model 26C3D079

还是会随机，如果在设置里面把PedRandomizer = false，就不会读取人物池：\[1741621883]: Ped models: 1079, Vehicle models: 882

看看能不能在PedRandomizer = false情况下能读取人物池，并且这样人物也不会随机了

GitHub Copilot: 我明白了,问题是需要将人物池(ped hash)的加载与随机化功能分开。我们需要修改以下文件:

### [peds.hh](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/peds/peds.hh)

在PedRandomizer\_Components的Config中添加EnablePedPool字段:

```C++
class PedRandomizer_Components  
{
public:
    static auto &
    Config ()
    {
        static struct Config
        {
            // ...existing code...
            bool        EnablePedPool            = true; // 控制是否加载人物池,与随机化分开
            // ...existing code...
        } m_Config;

        return m_Config;
    }
    // ...existing code...
};
```

### [common.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/common/common.cc)

修改InitialiseHashes函数根据EnablePedPool来决定是否加载人物池:

```C++


已进行更改。

void
Common::InitialiseHashes ()
{
    // 检查是否需要加载人物池
    bool loadPeds = PedRandomizer_Components::Config().EnablePedPool;

    for (size_t i = 0; i < CStreaming::ms_aModelPointers->m_nAllocated; i++)
    {
        auto info = CStreaming::ms_aModelPointers->m_pData[i];
        if (!info)
            continue;

        auto type = info->GetType();

        switch (type)
        {
            case MODEL_INFO_PED: {
                if (loadPeds) {
                    mPedHashes.push_back(info->m_nHash);
                }
                break;
            }

            case MODEL_INFO_VEHICLE: {
                mVehicleHashes.push_back(info->m_nHash);
                break;
            }

            default: break;
        }
    }

    Logger::LogMessage ("Initialised model hashes");
    Logger::LogMessage ("Ped models: %d, Vehicle models: %d", 
                       mPedHashes.size (), mVehicleHashes.size ());

    mHashesInitialised = true;
}
```

### [config.toml](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/config.toml)

添加EnablePedPool配置项:

```TOML


已进行更改。

// ...existing code...
[PedRandomizer]

# 即使PedRandomizer=false时也加载人物池,以支持过场动画模型映射
EnablePedPool = true 

RandomizePlayer = true
RandomizePeds = true
// ...existing code...
```

这些修改能让我们:

1. 通过EnablePedPool单独控制是否加载人物池
2. 即使PedRandomizer = false 也可以加载池,从而支持模型映射功能
3. 保持模型映射功能正常工作,但不随机化人物

这样就可以做到:

* PedRandomizer = false 时不随机化
* 同时仍然能读取人物池支持模型映射
* 通过EnablePedPool灵活控制是否加载人物池

已进行更改。

找到具有 1 个许可证类型的类似代码

lnyer: 严重性	代码	说明	项目	文件	行	禁止显示状态	详细信息
错误	C2653	“PedRandomizer\_Components”: 不是类或命名空间名称	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\common\common.cc	23
错误	C3861	“Config”: 找不到标识符	V.Rainbomizer	D:\Source\随机所有-V.Rainbomizer\复刻\src\common\common.cc	23

GitHub Copilot: 明白了,问题是在common.cc中缺少对PedRandomizer\_Components的引用。我们需要修改以下文件:

### [common.cc](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/common/common.cc)

添加头文件引用并调整代码:

```C++
#include "Utils.hh"
#include "common.hh"
#include "CStreaming.hh"
#include "CModelInfo.hh"
#include "peds/peds.hh"  // 添加这个头文件引用
#include <cstring>
#include <filesystem>
#include "logger.hh"
#include <rage.hh>
#include <Natives.hh>
#include <cstdlib>
#include <system_error>
#include <array>

void (*gameSkeleton__Init) (gameSkeleton *, uint32_t);

namespace Rainbomizer {

/*******************************************************/
void
Common::InitialiseHashes ()
{
    // 默认总是加载人物池,除非显式禁用
    bool loadPeds = true;
    
    // 如果PedRandomizer被引入,则使用其配置
    #ifdef ENABLE_PED_RANDOMIZER
    if(PedRandomizer_Components::Config().EnablePedPool == false) {
        loadPeds = false;
    }
    #endif

    // ...existing code...
    for (size_t i = 0; i < CStreaming::ms_aModelPointers->m_nAllocated; i++)
    {
        // ...existing code...
        switch (type)
        {
            case MODEL_INFO_PED: {
                if (loadPeds) {
                    mPedHashes.push_back(info->m_nHash);
                }
                break;
            }
            // ...existing code...
        }
    }
    // ...existing code...
}

// ...existing code...
} // namespace Rainbomizer
```

### [CMakeLists.txt](file:///d%3A/Source/%E9%9A%8F%E6%9C%BA%E6%89%80%E6%9C%89-V.Rainbomizer/%E5%A4%8D%E5%88%BB/src/common/CMakeLists.txt)

添加或修改编译配置:

```CMake


已进行更改。

# ...existing code...

# 如果启用了PedRandomizer功能
if(ENABLE_PED_RANDOMIZER)
    add_definitions(-DENABLE_PED_RANDOMIZER)
endif()

# ...existing code...
```

这些修改:

1. 添加了PedRandomizer\_Components相关的头文件引用
2. 使用条件编译来避免直接依赖PedRandomizer
3. 默认总是加载人物池,除非通过PedRandomizer的配置显式禁用
4. 添加了CMake配置用于控制是否启用PedRandomizer功能

这样可以:

1. 修复编译错误
2. 保持代码模块之间的松耦合
3. 提供配置选项来控制是否加载人物池
4. 在没有PedRandomizer时仍能正常工作

已进行更改。

找到具有 1 个许可证类型的类似代码
